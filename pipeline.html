<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pipeline do Processamento de Imagem</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg1: #020617;
    --bg2: #081028;
    --accent: #00f0ff;
    --accent-2: #4cc9f0;
    --glass: rgba(255,255,255,0.04);
    --glass-2: rgba(255,255,255,0.03);
    --text: #e6f7ff;
    --muted: #9bb7c7;
    --card-radius: 18px;
  }

  html,body{height:100%;margin:0;font-family:"Poppins",system-ui,Segoe UI,Roboto,Arial; background: radial-gradient(1200px 700px at 10% 10%, rgba(8,16,40,0.6), transparent), radial-gradient(900px 500px at 90% 90%, rgba(0,120,200,0.06), transparent), linear-gradient(180deg,var(--bg1),var(--bg2)); color:var(--text); -webkit-font-smoothing:antialiased;}
  .wrap{max-width:1200px;margin:28px auto;padding:28px;}
  header{display:flex;align-items:center;gap:18px;margin-bottom:22px}
  .logo{
    width:64px;height:64px;border-radius:14px;background:linear-gradient(135deg,var(--accent),var(--accent-2));
    display:flex;align-items:center;justify-content:center;box-shadow:0 8px 30px rgba(0,200,255,0.08);
    transform:rotate(-8deg);
  }
  .logo svg{filter:drop-shadow(0 6px 20px rgba(0,180,255,0.12));}
  h1{font-size:1.6rem;margin:0}
  p.lead{color:var(--muted);margin:6px 0 0;font-size:0.95rem}

  /* Stage area */
  .stage{
    margin-top:18px;
    display:grid;
    grid-template-columns: 1fr 420px;
    gap:28px;
    align-items:start;
  }

  /* Left: pipeline canvas */
  .visual {
    position:relative;
    min-height:420px;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    border-radius:20px;
    padding:26px;
    overflow:hidden;
    box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.03);
  }

  /* particle canvas covers the panel */
  canvas#particles{ position:absolute; inset:0; z-index:0; }

  /* pipeline row */
  .pipeline-row {
    position:relative;
    z-index:2;
    display:flex;
    gap:18px;
    align-items:center;
    justify-content:center;
    padding:30px 20px;
  }

  /* each card */
  .stage-card{
    width:160px;height:160px;border-radius:16px;background:linear-gradient(180deg,var(--glass),var(--glass-2));
    border:1px solid rgba(255,255,255,0.06);
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    box-shadow:0 6px 22px rgba(0,0,0,0.5);
    transition:transform 0.35s cubic-bezier(.2,.9,.3,1), box-shadow 0.35s;
    cursor:pointer;
    position:relative;
    overflow:visible;
  }
  .stage-card:hover{ transform:translateY(-10px) scale(1.04); box-shadow:0 20px 50px rgba(0,200,255,0.12); }
  .stage-icon{ font-size:34px; margin-bottom:10px; filter:drop-shadow(0 2px 8px rgba(0,180,255,0.12)); }
  .stage-title{ color:var(--accent); font-weight:700; letter-spacing:0.2px; font-size:0.98rem; }
  .stage-sub{ color:var(--muted); font-size:0.82rem; margin-top:6px; text-align:center; padding:0 8px }

  /* animated connector lines (SVG) */
  svg.connector{ position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; pointer-events:none; }

  /* flow particle (tiny) */
  .flow-dot{ position:absolute;width:10px;height:10px;border-radius:50%; background:var(--accent); box-shadow:0 6px 22px rgba(0,240,255,0.12); }

  /* right panel details */
  .panel {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius: var(--card-radius);
    padding:18px;
    border:1px solid rgba(255,255,255,0.04);
    min-height:420px;
    box-shadow: 0 8px 30px rgba(2,6,20,0.5);
  }
  .panel h2{ margin:4px 0 6px;font-size:1.05rem;color:var(--accent-2) }
  .panel p{ color:var(--muted); line-height:1.45 }
  .panel .matrix { margin-top:12px; display:grid; grid-template-columns: repeat(8,24px); gap:6px; justify-content:start; }
  .matrix .cell{ width:24px;height:24px;border-radius:4px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted); box-shadow: inset 0 -2px 0 rgba(0,0,0,0.3); }

  .controls{ display:flex; gap:8px; margin-top:18px; flex-wrap:wrap }
  .btn{
    background:transparent;border:1px solid rgba(255,255,255,0.06);padding:10px 12px;border-radius:10px;color:var(--text);
    cursor:pointer;font-weight:600;font-size:0.9rem; transition:all .2s; display:inline-flex; gap:8px; align-items:center;
  }
  .btn:hover{ transform:translateY(-4px); box-shadow: 0 10px 30px rgba(0,200,255,0.06); border-color:var(--accent-2) }
  .btn.primary{ background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#002; border: none; box-shadow:0 10px 30px rgba(0,200,255,0.12) }

  /* code viewer */
  pre.codebox{ background: #00111a; color:#bfeffd; padding:12px;border-radius:10px; overflow:auto; max-height:220px; font-family:"JetBrains Mono",monospace; font-size:12.5px; border:1px solid rgba(255,255,255,0.03);}

  footer.small{ margin-top:18px;color:var(--muted); font-size:0.9rem; text-align:center }

  /* tooltip bubble */
  .tooltip {
    position:absolute; left:50%; transform:translateX(-50%); bottom:calc(100% + 12px);
    background:rgba(2,10,20,0.9); padding:10px 12px; border-radius:10px; font-size:0.82rem; color:var(--text);
    box-shadow:0 6px 20px rgba(0,0,0,0.6); opacity:0; pointer-events:none; transition:all .18s;
    white-space:nowrap; border:1px solid rgba(255,255,255,0.03);
  }
  .stage-card:hover .tooltip{ opacity:1; transform:translateX(-50%) translateY(-6px) }

  /* responsive */
  @media (max-width:980px){
    .stage{ grid-template-columns: 1fr; }
    .pipeline-row{ flex-wrap:wrap; gap:12px; padding:18px; justify-content:flex-start }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo" aria-hidden>
      <!-- stylized sensor icon -->
      <svg width="44" height="44" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="2" y="3" width="20" height="18" rx="4" fill="white" opacity="0.12"/>
        <circle cx="12" cy="12" r="4.2" stroke="white" stroke-opacity="0.9" stroke-width="1.2"/>
      </svg>
    </div>
    <div>
      <h1>Pipeline Futurista ‚Äî Processamento de Imagem</h1>
      <p class="lead">Visual interativo e explicativo do fluxo: captura ‚Üí A/D ‚Üí forma√ß√£o ‚Üí compress√£o ‚Üí processamento. Clique em qualquer etapa para ver detalhes e c√≥digo.</p>
    </div>
  </header>

  <section class="stage">
    <div class="visual" id="visual">
      <canvas id="particles"></canvas>

      <!-- SVG connectors (animated stroke) -->
      <svg class="connector" id="connector" viewBox="0 0 1000 560" preserveAspectRatio="none" aria-hidden="true">
        <!-- drawn dynamically by JS -->
      </svg>

      <div class="pipeline-row" id="pipelineRow">
        <!-- stage cards -->
        <div class="stage-card" data-key="capture" title="Captura da Luz">
          <div class="stage-icon">üì∏</div>
          <div class="stage-title">Captura</div>
          <div class="stage-sub">Sensor √≥ptico transforma luz em sinal</div>
          <div class="tooltip">Sensor + lente ‚Üí sinal el√©trico anal√≥gico</div>
        </div>

        <div class="stage-card" data-key="ad">
          <div class="stage-icon">üî≤</div>
          <div class="stage-title">Convers√£o A/D</div>
          <div class="stage-sub">Sinal anal√≥gico ‚Üí valores num√©ricos</div>
          <div class="tooltip">Conversor A/D: quantiza√ß√£o e amostragem</div>
        </div>

        <div class="stage-card" data-key="formation">
          <div class="stage-icon">üßÆ</div>
          <div class="stage-title">Forma√ß√£o</div>
          <div class="stage-sub">Matriz de pixels (0‚Äì255)</div>
          <div class="tooltip">Cria√ß√£o da imagem digital (matriz)</div>
        </div>

        <div class="stage-card" data-key="compression">
          <div class="stage-icon">üíæ</div>
          <div class="stage-title">Compress√£o</div>
          <div class="stage-sub">Salvar em JPEG/PNG/RAW</div>
          <div class="tooltip">Compress√£o com perdas ou sem perdas</div>
        </div>

        <div class="stage-card" data-key="processing">
          <div class="stage-icon">üß†</div>
          <div class="stage-title">Processamento</div>
          <div class="stage-sub">Filtros, IA, reconhecimento</div>
          <div class="tooltip">CPU/GPU: filtros, IA, OCR, etc.</div>
        </div>
      </div>

      <!-- animated flow dots container -->
      <div id="flowContainer" style="position:absolute; inset:0; z-index:3; pointer-events:none;"></div>
    </div>

    <aside class="panel" id="panel">
      <h2 id="panelTitle">Detalhes da Etapa</h2>
      <p id="panelDesc">Clique em uma etapa para ver a descri√ß√£o ampliada, amostra de dados (matriz de pixels) e trechos de c√≥digo em Python e Java que ilustram a etapa.</p>

      <div id="matrixArea" style="margin-top:12px;">
        <div style="display:flex;align-items:center;gap:8px;">
          <strong style="color:var(--accent)">Matriz (exemplo)</strong>
          <small style="color:var(--muted);margin-left:auto">Valores 0‚Äì255</small>
        </div>
        <div class="matrix" id="matrixGrid" aria-hidden="false"></div>
      </div>

      <div class="controls" style="margin-top:14px;">
        <button class="btn primary" id="playFlowBtn">‚ñ∂Ô∏è Iniciar fluxo</button>
        <button class="btn" id="resetBtn">üîÅ Resetar</button>
        <button class="btn" id="showCodeBtn">üìú Exibir c√≥digo</button>
      </div>

      <div style="margin-top:14px;">
        <div id="codeView" style="display:none">
          <h3 style="margin:6px 0 8px;color:var(--accent)">Exemplos</h3>
          <div id="codePython" style="display:none">
            <small style="color:var(--muted)">Python ‚Äî leitura e exibi√ß√£o simples de matriz (PIL / numpy)</small>
            <pre class="codebox" id="pycode">
from PIL import Image
import numpy as np

img = Image.open('exemplo.png').convert('L')  # grayscale
arr = np.array(img)            # matriz de pixels 0-255
print("shape:", arr.shape)
print(arr[:6,:6])              # mostra parte da matriz
            </pre>
          </div>

          <div id="codeJava" style="display:none">
            <small style="color:var(--muted)">Java (JavaFX) ‚Äî criar imagem a partir de matriz</small>
            <pre class="codebox" id="javacode">
int width = 200, height = 200;
WritableImage wimg = new WritableImage(width, height);
PixelWriter writer = wimg.getPixelWriter();
for (int y = 0; y &lt; height; y++) {
  for (int x = 0; x &lt; width; x++) {
    int gray = (int)(Math.random()*256);
    writer.setColor(x, y, Color.grayRgb(gray));
  }
}
            </pre>
          </div>
        </div>
      </div>

      <footer class="small">Dica: passe o mouse nas etapas para ver tooltips; clique para abrir detalhes. Bot√µes simulam o fluxo visual.</footer>
    </aside>
  </section>
</div>

<script>
/* ========== Utilities ========== */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

/* ========== Particle background ========== */
const canvas = document.getElementById('particles');
const ctx = canvas.getContext('2d');
let W = canvas.width = canvas.clientWidth;
let H = canvas.height = canvas.clientHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = canvas.clientWidth; H = canvas.height = canvas.clientHeight; initParticles(); });

let particles = [];
function initParticles(){
  particles = [];
  const amount = Math.round((W*H)/50000);
  for(let i=0;i<amount;i++){
    particles.push({
      x: Math.random()*W,
      y: Math.random()*H,
      r: Math.random()*1.3 + 0.4,
      vx: (Math.random()-0.5)*0.15,
      vy: (Math.random()-0.5)*0.15,
      alpha: Math.random()*0.8+0.2
    });
  }
}
function updateParticles(){
  ctx.clearRect(0,0,W,H);
  for(const p of particles){
    p.x += p.vx; p.y += p.vy;
    if(p.x<0) p.x = W;
    if(p.x>W) p.x = 0;
    if(p.y<0) p.y = H;
    if(p.y>H) p.y = 0;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,240,255,'+ (p.alpha*0.07) +')';
    ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    ctx.fill();
  }
}
initParticles();
(function loop(){ updateParticles(); requestAnimationFrame(loop); })();

/* ========== Build connectors as SVG lines between cards ========== */
const svg = document.getElementById('connector');
function buildConnectors(){
  // get bounding boxes, compute centers
  const row = document.getElementById('pipelineRow');
  const cards = Array.from(row.children);
  // clear
  svg.innerHTML = '';
  // compute positions relative to svg viewport
  const rect = document.getElementById('visual').getBoundingClientRect();
  const viewW = rect.width, viewH = rect.height;
  svg.setAttribute('viewBox', `0 0 ${Math.max(viewW,1000)} ${Math.max(viewH,560)}`);

  // map centers
  const centers = cards.map(c=>{
    const r = c.getBoundingClientRect();
    return { x: r.left - rect.left + r.width/2, y: r.top - rect.top + r.height/2, el:c };
  });

  // create path between successive centers
  for(let i=0;i<centers.length-1;i++){
    const a = centers[i], b = centers[i+1];
    // cubic curve for nice arc
    const dx = Math.abs(b.x - a.x);
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const mx = (a.x + b.x)/2;
    const controlY = Math.min(a.y,b.y) - Math.max(30, dx*0.15);
    const d = `M ${a.x.toFixed(1)} ${a.y.toFixed(1)} C ${mx.toFixed(1)} ${controlY.toFixed(1)}, ${mx.toFixed(1)} ${controlY.toFixed(1)}, ${b.x.toFixed(1)} ${b.y.toFixed(1)}`;
    path.setAttribute('d', d);
    path.setAttribute('stroke', 'rgba(0,240,255,0.12)');
    path.setAttribute('stroke-width','4');
    path.setAttribute('fill','none');
    path.setAttribute('stroke-linecap','round');
    path.setAttribute('stroke-linejoin','round');
    // animated dashed highlight
    const highlight = document.createElementNS('http://www.w3.org/2000/svg','path');
    highlight.setAttribute('d', d);
    highlight.setAttribute('stroke','url(#grad1)');
    highlight.setAttribute('stroke-width','3');
    highlight.setAttribute('fill','none');
    highlight.setAttribute('stroke-linecap','round');
    highlight.setAttribute('stroke-dasharray','120');
    highlight.setAttribute('stroke-dashoffset','120');
    highlight.style.transition = 'stroke-dashoffset 1.8s linear';
    svg.appendChild(path);
    svg.appendChild(highlight);
  }

  // gradient defs
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  defs.innerHTML = `
    <linearGradient id="grad1" x1="0" x2="1">
      <stop offset="0" stop-color="rgba(76,201,240,1)" />
      <stop offset="1" stop-color="rgba(0,240,255,0.9)" />
    </linearGradient>`;
  svg.prepend(defs);
}

/* initial build after small delay so layout computed */
setTimeout(buildConnectors, 220);
window.addEventListener('resize', ()=>{ setTimeout(buildConnectors,160); });

/* ========== Flow animation between nodes ========== */
let flowRunning = false;
const flowContainer = document.getElementById('flowContainer');

function animateFlowOnce(){
  const row = document.getElementById('pipelineRow');
  const cards = Array.from(row.children);
  // centers
  const rect = document.getElementById('visual').getBoundingClientRect();
  const centers = cards.map(c=>{
    const r = c.getBoundingClientRect();
    return { x: r.left - rect.left + r.width/2, y: r.top - rect.top + r.height/2 };
  });

  // spawn small dots moving along path
  function animateAlong(p0,p1,delay, duration=1100){
    const dot = document.createElement('div');
    dot.className = 'flow-dot';
    flowContainer.appendChild(dot);
    dot.style.left = (p0.x - 5) + 'px';
    dot.style.top = (p0.y - 5) + 'px';
    dot.style.opacity = '0';
    setTimeout(()=>{
      dot.style.opacity = '1';
      const start = performance.now();
      (function frame(t){
        const tnorm = Math.min(1,(t-start)/duration);
        // ease
        const e = (--tnorm)*tnorm*tnorm + 1;
        const x = p0.x + (p1.x - p0.x)*e;
        const y = p0.y + (p1.y - p0.y)*e - Math.sin(e*Math.PI)*18; // little arc
        dot.style.left = (x - 5) + 'px';
        dot.style.top = (y - 5) + 'px';
        if(performance.now() - start < duration) requestAnimationFrame(frame);
        else dot.remove();
      })(performance.now());
    }, delay);
  }

  // chain
  const total = centers.length;
  for(let i=0;i<total-1;i++){
    animateAlong(centers[i], centers[i+1], i*180);
  }
}

let flowInterval = null;
document.getElementById('playFlowBtn').addEventListener('click', ()=>{
  if(flowRunning){ flowRunning=false; document.getElementById('playFlowBtn').textContent='‚ñ∂Ô∏è Iniciar fluxo'; clearInterval(flowInterval); }
  else { flowRunning=true; document.getElementById('playFlowBtn').textContent='‚è∏Ô∏è Parar fluxo'; animateFlowOnce(); flowInterval = setInterval(animateFlowOnce, 900); }
});

/* reset button */
document.getElementById('resetBtn').addEventListener('click', ()=>{
  flowRunning=false; document.getElementById('playFlowBtn').textContent='‚ñ∂Ô∏è Iniciar fluxo'; clearInterval(flowInterval);
  flowContainer.innerHTML='';
});

/* ========== Stage interactions & panel updates ========== */
const cards = Array.from($$('.stage-card'));
const panelTitle = $('#panelTitle');
const panelDesc = $('#panelDesc');
const matrixGrid = $('#matrixGrid');
const codeView = $('#codeView');
const pythonBlock = $('#codePython');
const javaBlock = $('#codeJava');

const details = {
  capture: {
    title: 'Captura da Luz',
    desc: 'A luz da cena √© focada pela lente e atinge o sensor (CMOS/CCD). O sensor converte f√≥tons em sinal el√©trico anal√≥gico; ganho, ru√≠do e exposi√ß√£o afetam o sinal.',
    matrix: smallMatrix(8,8),
    showPython: true, showJava: false
  },
  ad: {
    title: 'Convers√£o Anal√≥gico ‚Üí Digital (A/D)',
    desc: 'O conversor A/D amostra o sinal e o quantiza em n√≠veis discretos (por exemplo 0‚Äì255 para 8 bits). Aqui surgem efeitos de quantiza√ß√£o e aliasing se par√¢metros forem inadequados.',
    matrix: smallMatrix(8,8,true),
    showPython: true, showJava: false
  },
  formation: {
    title: 'Forma√ß√£o da Imagem (Matriz de Pixels)',
    desc: 'A matriz resultante organiza valores de intensidade por pixel. Em imagens coloridas h√° 3 canais (R,G,B) ou um canal por pixel em escala de cinza.',
    matrix: smallMatrix(8,8),
    showPython: true, showJava: true
  },
  compression: {
    title: 'Compress√£o & Armazenamento',
    desc: 'Compress√£o com perdas (JPEG) reduz tamanho sacrificando parte da informa√ß√£o; sem perda (PNG, RAW) preserva a qualidade. Metadados e cabe√ßalhos descrevem a imagem em arquivo.',
    matrix: smallMatrix(8,8,false,true),
    showPython: false, showJava: true
  },
  processing: {
    title: 'Processamento (Filtros & IA)',
    desc: 'Etapa final: filtros, detec√ß√£o de bordas, ajuste de contraste, redes neurais para reconhecimento ou segmenta√ß√£o. Normalmente usa-se CPU/GPU especializadas.',
    matrix: smallMatrix(8,8),
    showPython: true, showJava: true
  }
};

function smallMatrix(cols, rows, noisy=false, quant=true){
  // returns flattened array rows*cols
  const r = rows || cols;
  const arr = [];
  for(let y=0;y<r;y++){
    for(let x=0;x<cols;x++){
      let v = Math.round( (Math.sin((x+1)*(y+1))*0.5 + 0.5) * 255 );
      if(noisy) v = Math.min(255, Math.max(0, v + Math.round((Math.random()-0.5)*60)));
      if(!quant) v = Math.round(v/16)*16; // coarser
      arr.push(v);
    }
  }
  return {cols, rows:r, data:arr};
}

function showDetails(key){
  const info = details[key];
  panelTitle.textContent = info.title;
  panelDesc.textContent = info.desc;
  // populate matrix
  matrixGrid.innerHTML = '';
  const c = info.matrix;
  matrixGrid.style.gridTemplateColumns = `repeat(${c.cols}, 24px)`;
  for(let i=0;i<c.data.length;i++){
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.textContent = c.data[i];
    // highlight larger values
    const v = c.data[i];
    if(v > 200) cell.style.background = 'linear-gradient(180deg, rgba(0,240,255,0.12), rgba(0,120,255,0.06))';
    if(v < 50) cell.style.background = 'rgba(255,255,255,0.02)';
    matrixGrid.appendChild(cell);
  }
  // show code
  codeView.style.display = 'block';
  pythonBlock.style.display = info.showPython ? 'block' : 'none';
  javaBlock.style.display = info.showJava ? 'block' : 'none';
}

/* attach click handlers */
cards.forEach(c=>{
  c.addEventListener('click', ()=>{
    cards.forEach(x=>x.style.boxShadow='');
    c.style.boxShadow = '0 30px 70px rgba(0,200,255,0.1)';
    const key = c.getAttribute('data-key');
    showDetails(key);
    // pulse connector highlight: animate stroke-dashoffset on highlights
    const highlights = svg.querySelectorAll('path[stroke-dasharray]');
    highlights.forEach((h, idx)=> {
      h.style.transition = 'none';
      h.setAttribute('stroke-dashoffset','120');
      setTimeout(()=>{ h.style.transition = 'stroke-dashoffset 1.3s linear'; h.setAttribute('stroke-dashoffset','0'); }, idx*80);
    });
  });
});

// default show first
setTimeout(()=>{ showDetails('capture'); cards[0].style.boxShadow='0 30px 70px rgba(0,200,255,0.1)'; }, 240);

/* show/hide code area */
$('#showCodeBtn').addEventListener('click', ()=>{
  if(codeView.style.display === 'block' && pythonBlock.style.display === 'none' && javaBlock.style.display === 'none'){
    // nothing to show
    alert('Nenhum snippet dispon√≠vel para esta etapa.');
    return;
  }
  // toggle visibility of the code view area
  codeView.style.display = (codeView.style.display === 'none') ? 'block' : 'none';
});

/* make connectors animate continuously (dashoffset cycles) */
setInterval(()=>{
  const highlights = svg.querySelectorAll('path[stroke-dasharray]');
  highlights.forEach((h, idx)=>{
    try{
      const cur = parseFloat(h.getAttribute('stroke-dashoffset') || '0');
      const next = (cur - 2.5);
      h.setAttribute('stroke-dashoffset', next);
    }catch(e){}
  });
}, 80);

</script>
</body>
</html>
