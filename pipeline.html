<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pipeline ‚Äî Dados ‚Üí Imagem (Face)</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#020617; --accent:#00f0ff; --accent2:#4cc9f0; --muted:#9bb7c7;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; font-family:Poppins,system-ui,Segoe UI,Roboto,Arial;
    background: radial-gradient(1000px 600px at 10% 10%, rgba(8,16,40,0.6), transparent),
                linear-gradient(180deg,#020617,#081028);
    color:#e7fbff; -webkit-font-smoothing:antialiased;
  }
  .wrap{max-width:1180px;margin:28px auto;padding:20px;}
  header{display:flex;gap:14px;align-items:center}
  .logo{width:60px;height:60px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent2));display:flex;align-items:center;justify-content:center;transform:rotate(-6deg);box-shadow:0 10px 40px rgba(0,200,255,0.08)}
  h1{margin:0;font-size:1.45rem}
  p.lead{margin:6px 0 0;color:var(--muted);font-size:0.95rem}

  .stage{display:grid;grid-template-columns:1fr 420px;gap:26px;margin-top:20px}
  .visual{background:rgba(255,255,255,0.01);border-radius:16px;padding:18px;position:relative;overflow:hidden;min-height:480px;border:1px solid rgba(255,255,255,0.03)}
  canvas#particles{position:absolute;inset:0;z-index:0}
  .pipeline-row{position:relative;z-index:2;display:flex;gap:16px;align-items:center;justify-content:center;padding:32px}
  .stage-card{width:150px;height:150px;border-radius:14px;background:linear-gradient(180deg,rgba(255,255,255,0.025),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:transform .35s,box-shadow .35s}
  .stage-card:hover{transform:translateY(-8px);box-shadow:0 24px 60px rgba(0,200,255,0.08)}
  .stage-icon{font-size:34px;margin-bottom:8px}
  .stage-title{color:var(--accent);font-weight:700}
  .stage-sub{color:var(--muted);font-size:0.82rem;text-align:center;margin-top:6px;padding:0 6px}
  svg.connector{position:absolute;inset:0;width:100%;height:100%;z-index:1;pointer-events:none}

  /* flow dots */
  .flow-dot{position:absolute;width:10px;height:10px;border-radius:50%;background:var(--accent);box-shadow:0 8px 28px rgba(0,240,255,0.12);z-index:3;pointer-events:none}

  /* right panel */
  .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.03);min-height:480px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  .panel h2{margin:4px 0 6px;color:var(--accent2)}
  .panel p{color:var(--muted);line-height:1.45}
  .matrix{display:grid;grid-template-columns:repeat(8,28px);gap:6px;margin-top:10px}
  .cell{width:28px;height:28px;border-radius:6px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;font-size:11px;color:var(--muted);box-shadow:inset 0 -2px 0 rgba(0,0,0,0.3)}

  .controls{display:flex;gap:8px;margin-top:14px}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:10px 12px;border-radius:10px;color:var(--text);cursor:pointer;font-weight:600}
  .btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#002;border:none}

  .codebox{background:#00111a;color:#bfeffd;padding:12px;border-radius:10px;overflow:auto;font-family:"JetBrains Mono",monospace;font-size:12px;border:1px solid rgba(255,255,255,0.03);max-height:180px}

  /* final reveal area */
  .reveal-area{position:absolute;right:24px;bottom:24px;width:260px;height:260px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:4}
  .reveal-canvas{width:220px;height:220px;border-radius:8px;position:relative;overflow:hidden;background:#00121a}
  .reveal-canvas img{display:block;max-width:100%;height:100%;object-fit:cover;opacity:0}
  .status{margin-top:8px;color:var(--muted);font-size:0.92rem}

  /* tiles (data -> image) */
  .tiles-wrap{position:absolute;inset:0;z-index:6;pointer-events:none}
  .tile{
    position:absolute; width:0px;height:0px; opacity:0; will-change:transform,opacity;
    background-repeat:no-repeat; background-size:cover; border-radius:2px; box-shadow:0 6px 18px rgba(0,0,0,0.45);
    transform-origin:center center;
  }

  .badge{
    margin-top:10px;padding:6px 10px;border-radius:999px;background:linear-gradient(90deg,#18f0c8,#1fb9ff);color:#001;font-weight:700;box-shadow:0 8px 30px rgba(0,200,255,0.1)
  }

  @media (max-width:980px){ .stage{grid-template-columns:1fr; } .reveal-area{position:static;margin-top:14px;} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo" aria-hidden>
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none"><rect x="2" y="3" width="20" height="18" rx="4" fill="white" opacity="0.12"/><circle cx="12" cy="12" r="3.6" stroke="white" stroke-width="1"/></svg>
    </div>
    <div>
      <h1>Pipeline Interativo ‚Äî Dados ‚Üî Imagem (Reconhecimento Facial)</h1>
      <p class="lead">Clique em ‚ÄúIniciar fluxo‚Äù e veja os dados serem lidos, transformados e ‚Äî no final ‚Äî formarem a face. Arquivo GIF: <code>danysface.gif</code> (coloque na mesma pasta).</p>
    </div>
  </header>

  <section class="stage">
    <div class="visual" id="visual">
      <canvas id="particles"></canvas>
      <svg class="connector" id="connector" viewBox="0 0 1000 560" preserveAspectRatio="none" aria-hidden="true"></svg>

      <div class="pipeline-row" id="pipelineRow">
        <div class="stage-card" data-key="capture">
          <div class="stage-icon">üì∏</div>
          <div class="stage-title">Captura</div>
          <div class="stage-sub">Sensor ‚Üí sinal anal√≥gico</div>
        </div>
        <div class="stage-card" data-key="ad">
          <div class="stage-icon">üî≤</div>
          <div class="stage-title">A/D</div>
          <div class="stage-sub">Quantiza√ß√£o e amostragem</div>
        </div>
        <div class="stage-card" data-key="formation">
          <div class="stage-icon">üßÆ</div>
          <div class="stage-title">Forma√ß√£o</div>
          <div class="stage-sub">Matriz de pixels</div>
        </div>
        <div class="stage-card" data-key="compression">
          <div class="stage-icon">üíæ</div>
          <div class="stage-title">Compress√£o</div>
          <div class="stage-sub">Salvar / transmitir</div>
        </div>
        <div class="stage-card" data-key="processing">
          <div class="stage-icon">üß†</div>
          <div class="stage-title">Processamento</div>
          <div class="stage-sub">Extra√ß√£o / valida√ß√£o</div>
        </div>
      </div>

      <!-- reveal face area (bottom-right) -->
      <div class="reveal-area" id="revealArea">
        <div class="reveal-canvas" id="revealCanvas">
          <!-- image must be present in same folder as the HTML -->
          <img id="faceGif" src="danyface.gif" alt="face gif">
          <div class="tiles-wrap" id="tilesWrap"></div>
        </div>
        <div class="status" id="statusText">Status: aguardando execu√ß√£o</div>
        <div class="badge" id="badge" style="display:none">‚úÖ Identidade validada</div>
      </div>
    </div>

    <aside class="panel">
      <h2 id="panelTitle">Detalhes</h2>
      <p id="panelDesc">Clique em uma etapa para ver a descri√ß√£o, ou pressione <strong>Iniciar fluxo</strong> para ver todo o processo animado.</p>

      <div style="margin-top:10px;">
        <strong style="color:var(--accent2)">Matriz (exemplo)</strong>
        <div class="matrix" id="matrixGrid"></div>
      </div>

      <div class="controls">
        <button class="btn primary" id="startBtn">‚ñ∂Ô∏è Iniciar fluxo</button>
        <button class="btn" id="stopBtn">‚è∏Ô∏è Parar</button>
        <button class="btn" id="resetBtn">üîÅ Resetar</button>
        <button class="btn" id="revealBtn">‚ú® Revelar face agora</button>
      </div>

      <div style="margin-top:12px;">
        <div class="codebox">
<small style="color:var(--muted)">Snippet (Python) ‚Äî leitura r√°pida e extra√ß√£o da matriz:</small>

<pre style="margin:6px 0 0">
from PIL import Image
import numpy as np

img = Image.open('danyface.gif').convert('L')
arr = np.array(img)
print(arr.shape)
print(arr[:6,:6])
</pre>
        </div>
      </div>

    </aside>
  </section>
</div>

<script>
/* ============================ Particles background ============================ */
const canvas = document.getElementById('particles');
const ctx = canvas.getContext('2d');
function resizeCanvas(){ canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
resizeCanvas(); window.addEventListener('resize', ()=>{ resizeCanvas(); initParticles(); buildConnectors(); });
let W = canvas.width, H = canvas.height;
let particles = [];
function initParticles(){
  W = canvas.width; H = canvas.height;
  particles = [];
  const count = Math.max(30, Math.round((W*H)/80000));
  for(let i=0;i<count;i++){
    particles.push({x:Math.random()*W, y:Math.random()*H, r: Math.random()*1.6+0.6, vx:(Math.random()-0.5)*0.2, vy:(Math.random()-0.5)*0.2, a: Math.random()*0.8+0.2});
  }
}
function drawParticles(){
  ctx.clearRect(0,0,W,H);
  for(const p of particles){
    p.x+=p.vx; p.y+=p.vy;
    if(p.x<0) p.x=W; if(p.x>W)p.x=0; if(p.y<0)p.y=H; if(p.y>H)p.y=0;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,240,255,'+(p.a*0.07)+')';
    ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
  }
  requestAnimationFrame(drawParticles);
}
initParticles(); drawParticles();

/* ============================ Connectors (SVG) ============================ */
const svg = document.getElementById('connector');
function buildConnectors(){
  svg.innerHTML = '';
  const rect = document.getElementById('visual').getBoundingClientRect();
  svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
  const row = document.getElementById('pipelineRow');
  const cards = Array.from(row.children);
  const centers = cards.map(c => {
    const r = c.getBoundingClientRect();
    return {x: r.left - rect.left + r.width/2, y: r.top - rect.top + r.height/2};
  });

  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  defs.innerHTML = `<linearGradient id="g1"><stop offset="0" stop-color="#4cc9f0"/><stop offset="1" stop-color="#00f0ff"/></linearGradient>`;
  svg.appendChild(defs);

  for(let i=0;i<centers.length-1;i++){
    const a = centers[i], b = centers[i+1];
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const mx = (a.x + b.x)/2;
    const controlY = Math.min(a.y,b.y)-40;
    const d = `M ${a.x} ${a.y} C ${mx} ${controlY} ${mx} ${controlY} ${b.x} ${b.y}`;
    path.setAttribute('d', d);
    path.setAttribute('stroke', 'rgba(0,240,255,0.14)');
    path.setAttribute('stroke-width','3');
    path.setAttribute('fill','none');
    svg.appendChild(path);
    const h = document.createElementNS('http://www.w3.org/2000/svg','path');
    h.setAttribute('d', d); h.setAttribute('stroke','url(#g1)'); h.setAttribute('stroke-width','2.5');
    h.setAttribute('stroke-dasharray','120'); h.setAttribute('stroke-dashoffset','120');
    svg.appendChild(h);
  }
}
setTimeout(buildConnectors, 200);

/* animate connector highlights */
setInterval(()=>{ const hs = svg.querySelectorAll('path[stroke-dasharray]'); hs.forEach((h,i)=>{ let cur=parseFloat(h.getAttribute('stroke-dashoffset')||0); h.setAttribute('stroke-dashoffset', (cur-3)%240); }); },60);

/* ============================ Flow animation ============================ */
const flowContainer = document.createElement('div'); flowContainer.style.position='absolute'; flowContainer.style.inset='0'; flowContainer.style.zIndex=3; flowContainer.style.pointerEvents='none';
document.getElementById('visual').appendChild(flowContainer);

function animateFlowStep(fromEl, toEl, delay=0){
  const rect = document.getElementById('visual').getBoundingClientRect();
  const a = fromEl.getBoundingClientRect(), b = toEl.getBoundingClientRect();
  const p0 = {x: a.left - rect.left + a.width/2, y: a.top - rect.top + a.height/2};
  const p1 = {x: b.left - rect.left + b.width/2, y: b.top - rect.top + b.height/2};
  const dot = document.createElement('div'); dot.className='flow-dot'; flowContainer.appendChild(dot);
  dot.style.left=(p0.x-5)+'px'; dot.style.top=(p0.y-5)+'px'; dot.style.opacity='0';
  setTimeout(()=>{
    dot.style.opacity='1';
    const start = performance.now();
    const dur = 1000;
    (function frame(now){
      const t = Math.min(1,(now-start)/dur);
      const ease = (--t)*t*t + 1; // ease out
      const x = p0.x + (p1.x-p0.x)*ease;
      const y = p0.y + (p1.y-p0.y)*ease - Math.sin(ease*Math.PI)*18;
      dot.style.left = (x-5)+'px'; dot.style.top=(y-5)+'px';
      if(performance.now()-start < dur) requestAnimationFrame(frame);
      else setTimeout(()=>dot.remove(),80);
    })(performance.now());
  }, delay);
}

/* orchestrate sequence */
let flowInterval = null;
let running=false;
const startBtn = document.getElementById('startBtn'), stopBtn = document.getElementById('stopBtn'), resetBtn = document.getElementById('resetBtn');
const cards = Array.from(document.querySelectorAll('.stage-card'));
const statusText = document.getElementById('statusText');
const badge = document.getElementById('badge');

startBtn.addEventListener('click', ()=>{
  if(running) return;
  running=true; statusText.textContent='Status: executando...';
  let i=0;
  function runOnce(){
    // animate dot from stage i to i+1
    if(i < cards.length -1){
      animateFlowStep(cards[i], cards[i+1], 60);
      highlightCard(cards[i+1]);
      i++;
      setTimeout(runOnce, 700);
    } else {
      // reached end: trigger reveal
      triggerReveal();
      running=false;
      statusText.textContent='Status: processamento finalizado';
      badge.style.display='inline-block';
    }
  }
  highlightCard(cards[0]); runOnce();
});

stopBtn.addEventListener('click', ()=>{
  running=false; statusText.textContent='Status: pausado';
});

resetBtn.addEventListener('click', ()=>{
  running=false; statusText.textContent='Status: aguardando execu√ß√£o';
  badge.style.display='none';
  clearTiles();
});

/* clicking stages shows info and sample matrix */
const matrixGrid = document.getElementById('matrixGrid');
const sampleMatrices = {
  capture: smallMatrix(8,8),
  ad: smallMatrix(8,8,true),
  formation: smallMatrix(8,8),
  compression: smallMatrix(8,8,false,true),
  processing: smallMatrix(8,8)
};
document.querySelectorAll('.stage-card').forEach(c=>{
  c.addEventListener('click', ()=>{
    const key = c.getAttribute('data-key');
    showMatrix(sampleMatrices[key]);
  });
});
function showMatrix(m){
  matrixGrid.innerHTML='';
  matrixGrid.style.gridTemplateColumns = `repeat(${m.cols},28px)`;
  m.data.forEach(v=>{
    const d = document.createElement('div'); d.className='cell'; d.textContent=v; 
    if(v>200) d.style.background='linear-gradient(180deg, rgba(0,240,255,0.14), rgba(0,120,255,0.06))';
    matrixGrid.appendChild(d);
  });
}
/* smallMatrix generator (same as previous) */
function smallMatrix(cols, rows, noisy=false, quant=true){
  const r = rows || cols;
  const arr = [];
  for(let y=0;y<r;y++){
    for(let x=0;x<cols;x++){
      let v = Math.round( (Math.sin((x+1)*(y+1))*0.5 + 0.5) * 255 );
      if(noisy) v = Math.min(255, Math.max(0, v + Math.round((Math.random()-0.5)*60)));
      if(!quant) v = Math.round(v/16)*16;
      arr.push(v);
    }
  }
  return {cols, rows:r, data:arr};
}
showMatrix(smallMatrix(8,8));

/* highlight card */
function highlightCard(el){
  document.querySelectorAll('.stage-card').forEach(x=>x.style.boxShadow='');
  el.style.boxShadow='0 30px 70px rgba(0,200,255,0.12)';
}

/* ==================== Tiles reveal: transform data -> image ==================== */
const tilesWrap = document.getElementById('tilesWrap');
const faceImg = document.getElementById('faceGif');
const revealCanvas = document.getElementById('revealCanvas');
const revealRect = revealCanvas.getBoundingClientRect();

/* build tiles grid and animate them to assemble into face */
function triggerReveal(tileCountX=24, tileCountY=24){
  clearTiles();
  badge.style.display='none';
  statusText.textContent='Status: revelando imagem a partir dos dados...';

  // ensure image loaded to know dimensions
  if(!faceImg.complete){
    faceImg.onload = ()=>{ buildTiles(tileCountX,tileCountY); }
  } else buildTiles(tileCountX,tileCountY);
}

function clearTiles(){
  tilesWrap.innerHTML='';
}

function buildTiles(nx, ny){
  const wrap = tilesWrap;
  const bounds = revealCanvas.getBoundingClientRect();
  const width = bounds.width, height = bounds.height;
  // set background-size for tiles: they will use the image as background with cover size equal to whole canvas
  // create tile DOM elements with initial "data" look (numbers) and random positions
  const tileW = Math.ceil(width / nx);
  const tileH = Math.ceil(height / ny);

  // position origin for final grid (centered inside revealCanvas)
  const offsetLeft = 0;
  const offsetTop = 0;

  // precompute background-size values (we want to map the full image to tile backgrounds)
  const bgSize = `${width}px ${height}px`;

  const tiles = [];
  for(let j=0;j<ny;j++){
    for(let i=0;i<nx;i++){
      const tx = offsetLeft + i*tileW;
      const ty = offsetTop + j*tileH;
      const bgPosX = -tx + 'px';
      const bgPosY = -ty + 'px';

      const t = document.createElement('div');
      t.className='tile';
      t.style.width = tileW + 'px';
      t.style.height = tileH + 'px';
      t.style.left = (Math.random()* (revealCanvas.clientWidth*1.6) - revealCanvas.clientWidth*0.3) + 'px';
      t.style.top = (Math.random()* (revealCanvas.clientHeight*1.6) - revealCanvas.clientHeight*0.3) + 'px';
      t.style.opacity = '0';
      t.style.transform = `scale(${Math.random()*0.6+0.4}) rotate(${(Math.random()-0.5)*80}deg)`;
      // show a numeric label to simulate "dados"
      t.innerHTML = `<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-family:JetBrains Mono,monospace;color:rgba(255,255,255,0.85);font-size:${Math.max(10,Math.floor(tileW/4))}px">${Math.floor(Math.random()*256)}</div>`;
      // background-image points to GIF file and background-position maps to reveal the proper fragment
      t.style.backgroundImage = `url('danyface.gif')`;
      t.style.backgroundSize = bgSize;
      t.style.backgroundPosition = `${bgPosX} ${bgPosY}`;
      t.style.borderRadius = '4px';
      wrap.appendChild(t);

      // store final coords
      tiles.push({el:t, fx:tx, fy:ty});
    }
  }

  // animate tiles into place (staggered)
  tiles.forEach((tile, idx)=>{
    const delay = idx * 8 + Math.random()*150;
    setTimeout(()=>{
      tile.el.style.transition = 'all 900ms cubic-bezier(.2,.9,.25,1), opacity 220ms';
      tile.el.style.left = tile.fx + 'px'; tile.el.style.top = tile.fy + 'px';
      tile.el.style.opacity = '1'; tile.el.style.transform = 'scale(1) rotate(0deg)';
      // after arrival, fade the numeric overlay and let background show
      setTimeout(()=>{
        const overlay = tile.el.firstElementChild;
        if(overlay) overlay.style.transition='opacity 420ms'; overlay.style.opacity='0';
      }, 320);
    }, delay);
  });

  // after all tiles assemble, reveal image underneath and show badge
  setTimeout(()=>{
    // show actual gif (set opacity)
    faceImg.style.transition='opacity 420ms'; faceImg.style.opacity='1';
    statusText.textContent='Status: imagem formada ‚Äî extraindo caracter√≠sticas...';
    setTimeout(()=>{ statusText.textContent='Status: valida√ß√£o conclu√≠da'; badge.style.display='inline-block'; }, 900);
  }, tiles.length * 8 + 900);
}

/* quick button to reveal immediately */
document.getElementById('revealBtn').addEventListener('click', ()=>{ triggerReveal(28,28); });

/* auto build connectors after small delay (layout stabilized) */
setTimeout(()=>{ buildConnectors(); }, 260);

/* clicking processing card triggers reveal */
document.querySelector('[data-key="processing"]').addEventListener('click', ()=>{ triggerReveal(26,26); });

/* keep svg connectors updating on resize */
window.addEventListener('resize', ()=>{ setTimeout(buildConnectors,120); });

</script>
</body>
</html>
